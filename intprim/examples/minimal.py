import numpy as np
import numpy.random
from intprim import bayesian_interaction_primitives as bip

# Disclaimer:
# Spatial noise and temporal noise are at odds with each other in conditioning.
# If you have a lot of spatial noise it will be more difficult to accurately locate the correct phase, and vice versa.
# So applications with lots of spatial noise AND lots of temporal noise may be challenging.
# Additionally, the following examples are atypical in that they are only 2 DOF and we're removing one of them during testing.
# Thus the localization problem is based entirely on 1 DOF with no redundancies, compounding the difficulty.

def minimal():
    np.random.seed(213413414)

    # Create sin/cos waves from 0 to 2pi.
    trajectory_length = 100
    sin_wave = np.sin(np.linspace(0, 2.0 * np.pi, trajectory_length))
    cos_wave = np.cos(np.linspace(0, 2.0 * np.pi, trajectory_length))

    # Initialize a BIP object with 2 DOF named "X" and "Y" which are approximated by 8 basis functions.
    primitive = bip.BayesianInteractionPrimitive(2, ['X', 'Y'], 8)

    # Add 30 demonstrations which are generated by applying an amplitude to each wave which is randomly sampled from a normal distribution.
    for demo in range(30):
        amplitude = np.random.normal(1.0, 5.0)
        primitive.add_demonstration(np.array([cos_wave * amplitude, sin_wave * amplitude]))

    # Create a test trajectory which has another randomly sampled amplitude.
    # Note that the observed x-values are set to 0, indicating (via the following noise matrix) that we don't have observations for them.
    amplitude = np.random.normal(1.0, 5.0)
    test_trajectory = np.array([cos_wave * amplitude, sin_wave * amplitude])
    test_trajectory_partial = np.array(test_trajectory, copy = True)
    test_trajectory_partial[0, :] = 0.0

    # Generating the observation noise matrix.
    # The variance for the X DOF is a very high value so that the observed x-values are not heavily weighted in conditional inference.
    # This is desirable because we don't have observed x-values, we want to generate them based on the observed y-values.
    # This mimics an HRI scenario in which we only observe one agent's actions and want to generate the other agent's actions in response.
    # The test trajectory does not have noise associated with it, so we set it to a low number (although not too low to avoid a high condition number).
    observation_noise = np.array([[100000.0, 0.0], [0.0, 0.1]])

    # We only want to observe a subset of the trajectory to mimic partial observation.
    # In this case, we only observe 10% of the trajectory.
    observable_samples = int(np.round(test_trajectory.shape[1] * 0.4))

    # Generate a response trajectory.
    # This will create a response conditioned on the (partially) observed test trajectory.
    # Typically we're only concerned with the unobserved DOF, however, all DOFs are returned here.
    gen_trajectory, phase = primitive.generate_probable_trajectory_recursive(test_trajectory_partial[:, :observable_samples], observation_noise, num_samples = 100 - observable_samples)

    # Plot the mean learned trajectory, the generated trajectory, and the test trajectory.
    mean_trajectory = primitive.get_mean_trajectory()
    primitive.plot_partial_trajectory(gen_trajectory, test_trajectory[:, :observable_samples], mean_trajectory)


def main():
    minimal()


if __name__ == '__main__':
    main()
